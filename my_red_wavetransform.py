# -*- coding: utf-8 -*-
"""my_red_wavetransform.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T6xkzBYCx_GxNGd1bxArGqQsy5xt4ht0
"""

from modwt import modwt, imodwt
import pandas as pd
import numpy as np
import bredvarnet_latest_function
import mytsdataset_latest

from bredvarnet_latest_function import BRedVARNet
from mytsdataset_latest import MyTimeSeriesDataset

def myredwavetransform(df ,
                    exo_test,
                    istest = True,
                    wname = 'haar',
                    lev = 4,
                    horizon_length = 4,
                    lags = 2,
                    num_epochs = 500,
                    hidden_size =9,
                    exo = None,
                    diff = False,
                    std = False):
  ######################
  ####MAking dummy data
  ######################
  if istest:
    additional_rows = pd.DataFrame(0, index=range(horizon_length), columns=df.columns)
    df = pd.concat([df, additional_rows], ignore_index=True)

  #############
  ## Subset
  ##############
  colnames = df.columns
  if exo is not None:
    df_exo = df[exo]
    df_endo = df.drop(columns = exo)
    d = len(df_endo.columns)
  else:
    df_endo = df
    d = len(df_endo.columns)

  ######################
  ###MODWT Transform
  ######################
  wt_transforms = []
  for col in df_endo.columns: #this part is fishy : are we including the 0th indexed variable?
    df_endo[col] = df_endo[col].astype(float)
    wt = modwt(df_endo[col], wname, lev)
    wt_transforms.append(wt)
  #print("wavelet trasnform coeff shape : " ,  wt_transforms[0].shape ,'\n')
  #print("wavelet trasnform coeff names : " ,  wt_transforms[0] ,'\n')

  wt_df_list = []
  for i in range(len(wt_transforms)):
    wt_df = pd.DataFrame(wt_transforms[i])
    wt_df = wt_df.transpose()
    wt_df_list.append(wt_df)
  #print('wt_df_list shape : ' , wt_df_list[0].shape ,'\n')
  #print('wt_df_list  : ' , wt_df_list[0] ,'\n')
  #############################
  ###Collecting Decompositions
  ##############################

  #COllect the decomposition of each level for every variable in separate dfs
  separate_dfs = []
  # Iterate over each index position
  for index in range(len(wt_transforms[0])):
    df_columns = []
    #iterate over each dataframe
    for df in wt_df_list:
        df_columns.append(df[index])  # Append the column at the current index position
    separate_dfs.append(pd.concat(df_columns, axis=1))

  #print('before forecasting df shape : ' , separate_dfs[0].shape)


  #############################
  ###Forecasting
  #############################
   ##Make forecasts with BRedVARNet including the exogenous variables
  ##If exogenous variables are present, following chunk is executed
  newseparate_dfs = []
  if exo is not None:
    for df in separate_dfs:
      foo = [df , df_exo]
      df = pd.concat(foo, axis = 1)
      newseparate_dfs.append(df)
  else:
    newseparate_dfs = separate_dfs

 ##Fit BRedVARNet and forecast!
  #print('before forecasting df shape : ' , newseparate_dfs[0].shape)
  #print('column names before forecasting' , newseparate_dfs[0].columns)
  forecasts_list = []
  for dframe in newseparate_dfs:
    dframe.columns = colnames
    #print('dframe shape : ' , dframe.shape)
    #print('dframe col names : ' , dframe.columns)
    forecasts_df = BRedVARNet(dframe, exo_test = exo_test ,standardise=std, num_epochs = num_epochs ,
                              differencing=diff , exo = exo , lags = lags , m_steps=horizon_length , hidden_size = hidden_size)
    forecasts_list.append(forecasts_df)
  #print('after forecasts shape: ' , forecasts_list[0].shape)



  #################################
  #### Taking inverse of modwt
  ##################################

  ##Collecting all decompostions of eahc variable
  inverse_forecasts_list = []
  final_forecasts = []
  dataconcat = pd.concat(forecasts_list , axis = 1)
  #print('final concat shape : ' , dataconcat.shape)
  #print('final concat df : ' , dataconcat)

  for i in range(len(wt_transforms)):
    features = forecasts_list[0].shape[1]
    ind_seq = np.arange(start = i , stop = dataconcat.shape[1], step = features)
    dfnew = dataconcat.iloc[ : ,  ind_seq] #replace 6 by no of endogenous variables in df
    final_forecasts.append(dfnew)
  #print('df for inverse transformation:' , final_forecasts[0])
  #print('df for inverse transformation shape:' , final_forecasts[0].shape)
  ##Inverse modwt
  for df in final_forecasts:
    df_np = df.transpose().to_numpy()
    inverse_df = imodwt(df_np, wname) #replace 'haar '
    inverse_forecasts_list.append(pd.DataFrame(inverse_df))
    #print('inverse df: ' ,inverse_df , '\n')


  final_forecast = pd.concat(inverse_forecasts_list , axis =1)
  final_forecast.columns = df_endo.columns
  return final_forecast
