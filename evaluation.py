# -*- coding: utf-8 -*-
"""Evaluation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ut7sY3BGJa4wf2hWZN7KRBfxuuTrDmqE

Install properscoring for crps
"""

#!pip install properscoring

"""Imports"""

import numpy as np
import pandas as pd
from properscoring import crps_gaussian

"""**Performance evlauation(df , forecasts_df , horizon_length)**:

"""

def perform_evaluation(df , forecasts_df, horizon_length):


    #input validation
    if df.shape[1] != forecasts_df.shape[1]:
      raise ValueError("Data DataFrame must have same no of column.")

    if forecasts_df.shape[0] < horizon_length:
      raise ValueError("Forecasts DataFrame must be equal to horizon_lenghth.")


    #Initialization
    epsilon = 1e-10
    # Initialize a dictionary to store the metrics for each column
    metrics = {
                  'MSE': [],
                  'SMAPE': [],
                  'MASE': [],
                  'RMSE': [],
                  'MAE': [],
                  'SMDAPE': [],
                  'Theil\'s U1': [],
                  'CRPS': []
             }

    data_test = df.iloc[-horizon_length:, :]


    #Metric evaluation
    for i in range( 0 ,df.shape[1]):

      forecasts = forecasts_df.iloc[:, i].values
      actuals = data_test.iloc[:, i].values

      #mse
      mse= np.mean((forecasts- actuals) ** 2)


      #smape
      smape = 100 * np.mean(2 * np.abs(forecasts - actuals) / (np.abs(forecasts) + np.abs(actuals)))

      #rmse
      rmse = np.sqrt(np.mean((forecasts - actuals) ** 2))

      #mae
      mae = np.mean(np.abs(forecasts - actuals))

      #smdape
      smdape = 100 * np.median(2 * np.abs(forecasts - actuals) / (np.abs(forecasts) + np.abs(actuals) + epsilon ))


      #Theiel's u1
      numerator = np.sqrt(np.mean((forecasts - actuals) ** 2))
      denominator = np.sqrt(np.mean(forecasts ** 2)) + np.sqrt(np.mean(actuals ** 2))
      theils_u1 = numerator / denominator

      #crps
      std_dev = np.std(forecasts - actuals) + epsilon
      crps = np.mean(crps_gaussian(actuals, mu=forecasts, sig=std_dev))


      #mase
      training_series = df.iloc[:-horizon_length , i].values.flatten()
      n = actuals.shape [0]
      d = np.abs(np.diff(training_series)).mean()
      errors = np.abs(forecasts - actuals)
      mase =  errors.mean() / d

      #append  lists in the dictionary
      metrics['SMAPE'].append(smape)
      metrics['MASE'].append(mase)
      metrics['RMSE'].append(rmse)
      metrics['MAE'].append(mae)
      metrics['SMDAPE'].append(smdape)
      metrics['Theil\'s U1'].append(theils_u1)
      metrics['CRPS'].append(crps)
      metrics['MSE'].append(mse)

    metrics_df = pd.DataFrame(metrics).transpose()
    metrics_df.columns = df.columns

    return metrics_df

"""**Useage Example**"""

# #load the data
# data = pd.read_csv('mvtseries.csv')
# data = data.drop('Unnamed: 0' , axis = 1)
# forecasts_df = pd.read_csv('shovon_results.csv')

# #prepare the data
# horizon_length = 4
# forecasts_df.iloc[ 0 , : ] = 1
# forecasts_df = forecasts_df.iloc[ : horizon_length, :3]

# #perform evaludation
# perform_evaluation(data , forecasts_df , horizon_length)

"""**Forecast**"""